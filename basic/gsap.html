<!DOCTYPE html>
<html lang="kr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <title>gsap</title>
</head>
<body>
    <style>
body {
  min-height: 500vh;
  margin:0;
  background-color: #111;
  background-image:
    linear-gradient(rgba(255,255,255,.07) 2px, transparent 2px),
    linear-gradient(90deg, rgba(255,255,255,.07) 2px, transparent 2px),
    linear-gradient(rgba(255,255,255,.06) 1px, transparent 1px),
    linear-gradient(90deg, rgba(255,255,255,.06) 1px, transparent 1px);
  background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
  background-position: -2px -2px, -2px -2px, -1px -1px, -1px -1px;
}

h2, .box {
  /* margin-bottom: 100vh; */
}
h2 {
  text-align: center;
}

.box {
  background-color: green;
  width: 100px;
  height: 100px;
}
    </style>



    <div style="height:2000px"></div>

    <div class="bb" style="padding-top:0;">
      <div class="box box3"><p>box3</p></div>
    </div>


    <div class="aa" style="padding-top:0;">
      <div class="box box1" style="margin:0;">box1</div>
      <div class="box">box</div>
    </div>



    

    <div class="box box2">box2</div>
    <div class="box box4">box4</div>
    <div class="box box4-end" style="margin-top:2000px">box4-end</div>


    <div class="pin"></div>
    <div style="height:2000px"></div>
    <script>
const boxes = gsap.utils.toArray('.box1');
boxes.forEach(box => {
  gsap.to(box, { 
    x: 100,
    y: 200,
    scrollTrigger: {
      // trigger: box, // 자기 자신
      trigger: ".aa", // 부모요소 지정
      start: 'center 50%', // 엘리먼트 영역, trigger 영역
      end: 'bottom bottom', // 엘리먼트 영역, trigger 영역
      // end: "+=400", // start 후 200px 이동 후 끝
      scrub: true,
      // markers: true,
      pin: ".pin", // .pin-spacer 가 생성되는데 뭔지 아직 파악 안됨
      onUpdate: (self) => console.log("direction:", self.direction),
      onToggle: (self) => console.log("toggled. active?", self.isActive),
    },
    // rotation: 360,
    duration: 1,
    // animation: tween
  })

// console.log(gsap);
});


let tl = gsap.timeline({
  // yes, we can add it to an entire timeline!
  scrollTrigger: {
    trigger: ".bb",
    pin: true, // pin the trigger element while active
    start: "top 70%", // when the top of the trigger hits the top of the viewport
    // end: "+=2000", // end after scrolling 500px beyond the start
    end: "top 10%", // end after scrolling 500px beyond the start
    scrub: 1, // smooth scrubbing, takes 1 second to "catch up" to the scrollbar
    snap: {
      snapTo: "labels", // snap to the closest label in the timeline
      duration: { min: 0.2, max: 3 }, // the snap animation should be at least 0.2 seconds, but no more than 3 seconds (determined by velocity)
      delay: 0.2, // wait 0.2 seconds from the last scroll event before doing the snapping
      ease: "power1.inOut", // the ease of the snap animation ("power3" by default)
    },
    // onUpdate: (self) => console.log("direction:", self.direction),
    // onToggle: (self) => console.log("toggled. active?", self.isActive),
    // onComplete: complete,
    // onCompleteParams:['오렌지',3],
    markers: true,
  },
});

function complete(a,b) {
  console.log(a, b)
}

console.log(tl.vars)

// add animations and labels to the timeline
tl.addLabel("start")
  .from(".box3 p", { scale: 0.3, rotation: 45, autoAlpha: 0 })
  .addLabel("color")
  .from(".box3", { backgroundColor: "#28a92b" })
  .addLabel("spin")
  .to(".box3", { rotation: 360 })
  .addLabel("end");



ScrollTrigger.create({
  trigger: ".box4",
  start: "top top",
  endTrigger: ".box4-end",
  // end: "bottom 50%+=100px",
  end: "bottom top",
  // markers: true,
  // onToggle: (self) => console.log("toggled, isActive:", self.isActive),
  /* onUpdate: (self) => {
    console.log(
      "progress:",
      self.progress.toFixed(3),
      "direction:",
      self.direction,
      "velocity",
      self.getVelocity()
    );
  }, */
});

    </script>
  </body>
</html>